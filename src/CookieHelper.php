<?php

namespace Pocket\Downloader;

use GuzzleHttp\Cookie\CookieJar;
use GuzzleHttp\Cookie\SetCookie;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Http\Client\PendingRequest;
use Pocket\Framework\Str;

class CookieHelper
{
    /**
     * Convert the contents of the Netscape Cookies file to an array of Cookies supported by GuzzleHttp
     *
     * ```
     * Netscape Cookies File Format
     *
     * # Netscape HTTP Cookie File
     * # http://curl.haxx.se/rfc/cookie_spec.html
     * # This file was generated by libcurl! Edit at your own risk.
     *
     * www.example.com        FALSE        /        FALSE        1338534278        name        value
     *
     * Domain   - The domain that created and can read the cookie.
     * Flag     - A TRUE or FALSE value indicating whether to include subdomains. This value is automatically set by the program, depending on whether Domain starts with . or not.
     * Path     - Valid path to the cookie in the domain.
     * Secure   - A TRUE or FALSE value indicating whether a secure connection to the domain is required to access the cookie, i.e. HTTPS only.
     * Expires  - The UNIX timestamp when the cookie expires.
     * Name     - The name of the cookie.
     * Value    - The value of the cookie.
     * ```
     *
     * @param string $cookies Netscape Cookies file path or file content
     * @param CookieJar|null $cookieJar If this parameter is provided, it will be populated as a CookieJar object
     * @return array Cookies array supported by Guzzle Http
     * @see CookieHelper::toNetscapeCookies()
     */
    public static function getNetscapeCookies(string $cookies, ?CookieJar &$cookieJar = null): array
    {
        $cookieItems = [];

        if (is_file($cookies)) {
            $cookies = file_get_contents($cookies);
        }
        $lines = explode(PHP_EOL, $cookies);
        foreach ($lines as $line) {
            $cookieItem = [];
            $httpOnly = false;

            // detect httponly cookies and remove #HttpOnly prefix
            if (str_starts_with($line, '#HttpOnly_')) {
                $line = substr($line, 10);
                $httpOnly = true;
            }

            // we only care for valid cookie definition lines
            if (!str_starts_with($line, '#') && substr_count($line, "\t") >= 6) {
                // get tokens in an array
                $tokens = explode("\t", $line, 7);
                // trim the tokens
                $tokens = array_map('trim', $tokens);

                // Extract the data
                // The name of the variable.
                $cookieItem['Name'] = urldecode($tokens[5]);
                // The value of the variable.
                $cookieItem['Value'] = urldecode($tokens[6]);
                // The domain that created AND can read the variable.
                $cookieItem['Domain'] = $tokens[0];
                // The path within the domain that the variable is valid for.
                $cookieItem['Path'] = $tokens[2];
                // The UNIX timestamp that the variable will expire on.
                $cookieItem['Expires'] = (int)$tokens[4];
                // Max-Age should be null.
                $cookieItem['Max-Age'] = null;
                // A TRUE/FALSE value indicating if a secure connection with the domain is needed to access the variable.
                $cookieItem['Secure'] = strtoupper($tokens[3]) === 'TRUE';
                // HttpOnly value
                $cookieItem['HttpOnly'] = $httpOnly;
                // A TRUE/FALSE value indicating if all machines within a given domain can access the variable.
                $cookieItem['Flag'] = strtoupper($tokens[1]) === 'TRUE';

                // Validate and record the cookie.
                if ($cookieItem['Domain'] !== null && $cookieItem['Domain'] !== '' && $cookieItem['Name'] !== '') {
                    $cookieItems[] = $cookieItem;
                }
            }
        }

        if (func_num_args() > 1) {
            $cookieJar = new CookieJar(false, $cookieItems);
        }

        return $cookieItems;
    }


    /**
     * Convert GuzzleHttp supported Cookies to Netscape Cookies file content
     *
     * @param array[]|CookieJar|SetCookie[] $cookies Cookie array or CookieJar supported by GuzzleHttp
     * @param string|null $saveCookieFile If this parameter is provided, the contents of Netscape Cookies will be saved to this file
     * @return string Returns the contents of the Netscape Cookies file on success, or an empty string on failure
     * @see CookieHelper::getNetscapeCookies()
     */
    public static function toNetscapeCookies(array|CookieJar $cookies, ?string $saveCookieFile = null): string
    {
        if ($cookies instanceof CookieJar) {
            $cookies = $cookies->toArray();
        }
        if (!is_array($cookies) || !$cookies) {
            return '';
        }

        $commentLines = [
            '# Netscape HTTP Cookie File',
            '# http://curl.haxx.se/rfc/cookie_spec.html',
            '# This is a generated file!  Do not edit.'
        ];
        $cookieLines = [];

        foreach ($cookies as $cookie) {
            if (!($cookie instanceof SetCookie)) {
                $cookie = new SetCookie(is_array($cookie) ? $cookie : []);
            }
            if ($cookie->validate() !== true) {
                continue;
            }

            $domain = $cookie->getDomain();
            $flag = Str::startsWith($domain, '.') ? 'TRUE' : 'FALSE';
            $path = $cookie->getPath();
            $secure = $cookie->getSecure() ? 'TRUE' : 'FALSE';
            $expires = $cookie->getExpires() ?: '0';
            $name = rawurlencode($cookie->getName());
            $value = rawurlencode($cookie->getValue());
            if ($cookie->getHttpOnly()) {
                $domain = '#HttpOnly_' . $domain;
            }

            $cookieLines[] = "{$domain}\t{$flag}\t{$path}\t{$secure}\t{$expires}\t{$name}\t{$value}";
        }

        if (!$cookieLines) {
            return '';
        }

        $cookieContents = implode("\n", $commentLines) . "\n\n" .
            implode("\n", $cookieLines);

        if ($saveCookieFile && pocket()->ensureDirectory(dirname($saveCookieFile))) {
            file_put_contents($saveCookieFile, $cookieContents, LOCK_EX);
        }

        return $cookieContents;
    }


    /**
     * Attach cookies to the request
     *
     * ```
     * The format of the parameter cookiesMap is as follows:
     * When it is a string, it can be a Netscape Cookies file path or file content.
     * When it is an array, the mapping array format is ['www.example.com' => ['key' => 'val', 'foo' => 'bar', ..]].
     * ```
     *
     * @param PendingRequest $request Request object
     * @param array|string $cookiesMap Netscape cookies or an array of cookies
     * @return PendingRequest
     */
    public static function attachCookies(PendingRequest $request, array|string $cookiesMap): PendingRequest
    {
        if (!$cookiesMap) {
            return $request;
        }

        $cookieJars = [];
        if (is_string($cookiesMap) && static::getNetscapeCookies($cookiesMap, $cookieJar)) {
            $cookieJars = [$cookieJar];
        } else if (is_array($cookiesMap)) {
            foreach ($cookiesMap as $domain => $cookies) {
                $cookieJars[] = CookieJar::fromArray($cookies, $domain);
            }
        }
        if ($cookieJars) {
            $allCookies = [];
            foreach ($cookieJars as $jar) {
                $allCookies = array_merge($allCookies, $jar->toArray());
            }
            $allCookieJar = new CookieJar(false, $allCookies);
            $request->withOptions([
                'cookies' => $allCookieJar
            ]);
        }

        return $request;
    }
}